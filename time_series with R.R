##################### 
#####1. 时间序列举例
#####################
#####################
#####洛杉矶年降水量
#####################
install.packages("TSA")
library(TSA)
win.graph(width = 4.875, height = 2.5, pointsize = 8) #产生一个win界面
data(larain)
larain
plot(larain, ylab = 'Inches', xlab = 'Year', type = 'o')

win.graph(width = 3, height = 3, pointsize = 8)
plot(y = larain, x = zlag(larain), ylab = 'Inches', xlab = 'Previous Year Inches')
#####################
#######化工过程
#####################
win.graph(width = 4.875, height = 2.5, pointsize = 8)
data(color)
plot(color, ylab = 'Color Property', xlab = 'Batch', type = 'o')

win.graph(width = 3, height = 3, pointsize = 8)
plot(y = color, x = zlag(color), ylab = 'Color Property', xlab = 'Previous Batch Color Property')


win.graph(width = 4.875, height = 2.5, pointsize = 8)
data(hare)
plot(hare, ylab = 'Abundance', xlab = 'Year', type = 'o')
#####################
######季节趋势
#####################
data(tempdub)
head(tempdub)
month. = season(tempdub)
head(month.)
model2 = lm(tempdub ~ month. - 1) # -1删除intercept term
summary(model2)

model3 = lm(tempdub ~ month.) 
summary(model3)
#####################
######余弦趋势
#####################
har. = harmonic(tempdub, 1)
model4 = lm(tempdub ~ har.)
summary(model4)

win.graph(width = 4.875, height = 2.5, pointsize = 8)
plot(ts(fitted(model4), freq = 12, start = c(1964, 1)), ylab = 'Temperature', type = 'l', ylim = range(c(fitted(model4), tempdub)))
points(tempdub)


plot(y = rstudent(model3), x = as.vector(time(tempdub)), 
     xlab = 'Time', ylab = 'Standardized Residuals', type = 'o')


plot(y = rstudent(model3), x = as.vector(fitted(model3)), xlab = 'Fitted Trend Values',
     ylab = 'Standarized Residuals', type = 'n')
points(y = rstudent(model3), x = as.vector(fitted(model3)), pch = as.vector(season(tempdub)))

hist(rstudent(model3), xlab = 'Standarized Residual')

win.graph(width = 2.5, height = 2.5, pointsize = 8)
qqnorm(rstudent(model3))
##########################################
########季节均值模型残差的样本自相关系数
##########################################
win.graph(width = 4.875, height = 3, pointsize = 8)
acf(rstudent(model3))
##########################################
##########用直线拟合随机游走得到的残差
##########################################
win.graph(width = 4.875, height = 3, pointsize = 8)
data(mal.2.s)
??ma2.s
ar1.s
ar1
library(zoo)
??ima22.s
data(ima22.s)
ima22.s
data(ma2.s)
head(ma2.s)

library(TSA)
data(ma1.2.s)
head(ma1.2.s)
win.graph(width = 4, height = 3, pointsize = 8)
data(ma2.s)
plot(ma2.s, ylab = expression(Y[t-1]), type = 'o')


data(oil.price)
plot(diff(log(oil.price)),main = "oil graph", ylab = "change in log(Price)", type = 'l')

data(ima22.s)
plot(ima22.s, ylab = 'IMA(2,2) Simulation', type = 'o')

?diff
?acf
?ar

win.graph(width = 4.875, height = 3, pointsize = 8)
data(color)
m1.color = arima(color, order = c(1, 0, 0))
m1.color
plot(rstandard(m1.color), ylab = 'Standarized Residuals', type = 'o')
abline(h = 0)

?arima

?acf
m1.color
acf(residuals(m1.color), plot = F)$acf
acf(residuals(m1.color), plot = T)

data(explode.s)
plot(explode.s, ylab = expression(Y[t]), type = 'o')

plot(diff(log(oil.price)), main = '石油价格序列取对数后的差分时序图', ylab = 'Change in Log(Price)', type = 'l')

data(ima22.s)
plot(ima22.s, main = 'IMA(2,2)',ylab = 'IMA(2,2) Simulation', type = 'o')

plot(diff(ima22.s), main = 'IMA(2,2)序列的一次差分', ylab = 'First Difference', type = 'o')

?diff

plot(diff(ima22.s, main = 'IMA（2，2）序列的二次差分', difference = 2), ylab = 'Differenced Twice', type ='o')

objects()

#
ts
ts(1:100, frequency = 1, start = 1959)
##########################################
######################plot.ts 与 ts.plot
##########################################
x <- -5:5
x
y <- 5*cos(x)
y
par(mfrow = c(1,2))
plot(x, main = "plot(x)")
plot(x, y, main = "plot(x,y)")

#plot.ts
plot.ts(x, main = "plot.ts(x")
plot.ts(x, y, main = "plot(x,y)")

#ts.plot
ts.plot(x, main = "ts.plot(x)")
ts.plot(ts(x), ts(y), col = 1:2, main = "ts.plot(x,y)")
?ts.plot
?lag.plot
?stl
?ts.intersect
?arima.sim

x1 <- arima.sim(list(order = c(1, 0, 0), ar = 0.9), n = 100)
x2 <- arima.sim(list(order = c(1, 0, 0), ar = -0.9), n = 100)
par(mfrow = c(1, 2))
plot(x1)
plot(x2)


par(mfcol=c(2,2))
acf(x1, 20)
acf(x2, 20)
pacf(x1, 20)
pacf(x2, 20)


x = arima.sim(list(order=c(0,0,1), ma=.8), n=100)
par(mfcol=c(3,1))
plot(x, main=(expression(MA(1)~~~theta==.8)))
acf(x,20)
pacf(x,20)

?arima.sim



x = arima.sim(list(order=c(2,0,0), ar=c(1,-.9)), n=100) 
par(mfcol=c(3,1))
plot(x, main=('expression(AR(2)~~~phi[1]==1~~~phi[2]==-.9)'))
acf(x, 20)
pacf(x, 20)

x = arima.sim(list(order=c(1,1,1), ar=.9, ma=-.5), n=200)
par(mfcol=c(3,1))
plot(x, main=('expression(ARIMA(1,1,1)~~~phi==.9~~~theta==-.5)'))
acf(x, 30)  # the process is not stationary, so there is no population [P]ACF ... 
pacf(x, 30) # but look at the sample values to see how they differ from the examples above


x = arima.sim(list(order=c(1,0,1), ar=.9, ma=-.5), n=100) # simulate some data
(x.fit = arima(x, order = c(1, 0, 1)))   # fit the model and print the results



tsdiag(x.fit, gof.lag=20) # you know the routine- ?tsdiag for details


x = arima.sim(list(order=c(1,0,1), ar=.9, ma=-.5), n=100) # simulate some data
(x.fit = arima(x, order = c(1, 0, 1)))   # fit the model and print the results
tsdiag(x.fit, gof.lag=20) # you know the routine- ?tsdiag for details

?tsdiag
methods(tsdiag)


x = arima.sim(list(order=c(1,0,1), ar=.9, ma=-.5), n=100) # simulate some data
(x.fit = arima(x, order = c(1, 0, 1)))   # fit the model and print the results
x.fore = predict(x.fit, n.ahead=10)  
# plot the forecasts
U = x.fore$pred + 2*x.fore$se
L = x.fore$pred - 2*x.fore$se
minx=min(x,L)
maxx=max(x,U)
ts.plot(x,x.fore$pred,col=1:2, ylim=c(minx,maxx))
lines(U, col="blue", lty="dashed")
lines(L, col="blue", lty="dashed") 

arima


u =read.table("http://www.stat.pitt.edu/stoffer/tsa2/data/globtemp2.dat")    # read the data
gtemp = ts(u[,2], start=1880, freq=1)      # yearly temp in col 2
plot(gtemp)  

arima(gtemp, order=c(1,1,1))

drift = 1:length(gtemp) #生成了一个名为drift的空数列，其长度与全球温度数列的长度相同
arima(gtemp, order=c(1,1,1), xreg=drift)
Coefficients:
  ar1      ma1   drift
0.2695  -0.8180  0.0061
s.e.  0.1122   0.0624  0.0030

gtemp

?arima
arima

library(nlme) #load the package
trend = time(mort) #assumes mort and part are there from previous examples
fit.lm = lm(mort~trend + part)  # ols
acf(resid(fit.lm))       # check acf and pacf of the resids
pacf(resid(fit.lm))      # or use acf2(resid(fit.lm)) if you have acf2
fit.gls = gls(mort~trend + part, correlation=corARMA(p=2), method="ML") # resids appear to be AR(2) ... now use gls() from nlme:
summary(fit.gls) 

(fit2.gls = arima(mort, order=c(2,0,0), xreg=cbind(trend, part))) 
Coefficients:
  ar1     ar2  intercept    trend    part
0.3980  0.4135  3132.7085  -1.5449  0.1503
s.e.  0.0405  0.0404   854.6662   0.4328  0.0211
sigma^2 estimated as 28.99:  log likelihood = -1576.56,  aic = 3165.13 

Box.test(resid(fit2.gls), 12, type="Ljung")   # and so on ...  
##########################################
#Box.test计算n独立的null假设
##########################################

x = arima.sim(list(order=c(2,0,0), ar=c(1,-.9)), n=2^8) # some data
(u = polyroot(c(1,-1,.9)))  # x is AR(2) w/complex roots   
?polyroot
Arg(u[1])/(2*pi)  # dominant frequency around .16:
par(mfcol=c(3,1))
plot.ts(x)
spec.pgram(x, spans=c(3,3), log="no")  # nonparametric spectral estimate; also see spectrum()
#对已生成的随机波动数据的频率进行估计。注意，在这里不能够使用自动回归模型作为已知条件来进行频率的计算，而是要对频率进行估计。
spec.ar(x, log="no")            # parametric spectral estimate


y1 <- rnorm(50, 0, 1)
y2 <- rnorm(50, 0, 1)
y <- c(y1, y2)
x <- ts(1:100, 1)
plot(y, x)

rchisq(48, 5)

?T

?acf

data(AirPassengers)
AP <- AirPassengers
AP
class(AP)
start(AP)
end(AP)
frequency(AP)
aggregate(AP)
?aggregate


file









##########################################
#A Little Book of R for Time Series
##########################################
?scan

##########################################
#读取时间序列数据
##########################################

####################################################
#http://robjhyndman.com/tsdldata/misc/kings.dat
#包含着从威廉一世开始的英国国王的去世年龄数据
####################################################

####################################################
#读取时间序列数据
####################################################
kings <- scan("http://robjhyndman.com/tsdldata/misc/kings.dat", skip = 3)
kings

####################################################
#将读入的数据存入到一个时间序列对象中
####################################################
kingstimeseries <- ts(kings)
kingstimeseries

####################################################
#ts可以用于指定frequency, start起始值，end结束值
####################################################



##########################################################
#一个样本数据集是从1946年1月到1959年12月的纽约每月
#出生人口数量（由牛顿最初收集）数据集可以从此链接下
#载（http://robjhyndman.com/tsdldata/data/nybirths.dat）
##########################################################
births <- scan("http://robjhyndman.com/tsdldata/data/nybirths.dat")
births
birthstimeseries <- ts(births, frequency = 12, start = c(1946, 1))
birthstimeseries



##########################################################
#http://robjhyndman.com/tsdldata/data/fancy.dat
#包含着一家位于昆士兰海滨度假圣地的纪念品商店
#从1987年1月到1987年12月的每月销售数据
##########################################################
souvenir <- scan("http://robjhyndman.com/tsdldata/data/fancy.dat")
souvenirtimeseries <- ts(souvenir, frequency = 12, start = c(1987, 1))
souvenirtimeseries


##########################################################
#plotting Time Series绘制时间序列图
##########################################################


##########################################################
#可使用R中的plot.ts（）函数来画时间序列图
##########################################################
plot.ts(kingstimeseries)
##########################################################
#变化不大，可用相加模型来描述
##########################################################


##########################################################
#画出一个纽约每月出生人口数量的时间序列图
##########################################################
plot.ts(birthstimeseries)
##########################################################
#这个时间序列在一定月份存在的季节性变动：在每年的夏天都
#有一个出生峰值，在冬季的时候进入波谷。同样，这样的时间
#序列也可能是一个相加模型，随着时间推移，季节性波动时大
#致稳定的而不是依赖于时间序列水平，且对着时间的变化，随
#机波动看起来也是大致稳定的。
##########################################################

##########################################################
#画出澳大利亚昆士兰州海滨度假圣地的纪念品商店从1987年1月
#到1987年12月的每月销售数据。
##########################################################
plot.ts(souvenirtimeseries)
##########################################################
#在这个案例中，看上去似乎相加模型不适合描述这个时间序列，
#因为这个季节性波动和随机变动的大小是随着时间序列逐步上
#升的水平。因此，我们需要将时间序列进行转换，以便得到一
#个可以用相加模型描述的时间序列。例如，我们对原始数据取
#自然对数进行转换计算：
##########################################################
logsouvenirtimeseries <- log(souvenirtimeseries)
plot.ts(logsouvenirtimeseries)
##########################################################
#可以看到季节性波动和随机变动的大小在对数变换后的时间序列
#上，随着时间推移，季节性波动和随机波动的大小是大致恒定的，
#并且不依赖于时间序列水平。因此，这个对数变换后的时间序列
#也许可以用相加模型进行描述。
##########################################################




##########################################################
#分解时间序列
##########################################################
##########################################################
#分解一个时间序列意味着把它拆分成构成元件，一般序列包含
#一个趋势部分、一个不规则部分，如果是一个季节性时间序列，
#则还有一个季节性部分。
##########################################################


##########################################################
#分解非季节性数据
##########################################################
##########################################################
#一个非季节性时间序列包含一个趋势部分和一个不规则部分。
#分解时间序列即为试图把时间序列拆分成这些成分，也就是说，
#需要估计趋势的和不规则的这两个部分

#为了估计出一个非季节性时间序列的趋势部分，
#使之能够用相加模型进行描述，最常用的方法便是平滑法，
#比如计算时间序列的简单移动平均。 

#在R的“TTR”包中的SMA()函数可以用
#简单的移动平均来平滑时间序列数据。
##########################################################
library(TTR)
?SMA
##########################################################
#SMA用于计算序列中的不同的MA
##########################################################
##########################################################
#使用SMA（）函数去平滑时间序列数据
#通过参数"n"指定来简单移动平均的
##########################################################
##########################################################
#kingstimeseries的plot呈现出非季节性
#且由于其随机变动在整个时间段内是大致不变的
#这个序列也可被描述为一个相加模型
#故可尝试使用简单移动平均平滑来估计趋势部分
#采用跨度不3的简单移动平均平滑时间序列数据
##########################################################
kingstimeseriesSMA3 <- SMA(kingstimeseries, n = 3)
plot.ts(kingstimeseriesSMA3)
##########################################################
#当我们使用跨度为3的简单移动平均平滑后，
#时间序列依然呈现出大量的随便波动。
#因此，为了更加准确地估计这个趋势部分，
#我们也许应该尝试下更大的跨度进行平滑。
#正确的跨度往往是在反复试错中获得的。
##########################################################
kingstimeseriesSMA8 <- SMA(kingstimeseries, n = 8)
plot.ts(kingstimeseriesSMA8)
##########################################################
#这个跨度为8的简单移动平均平滑数据的趋势部分看起来更加清晰了
#我们可以发现这个时间序列前20为国王去世年龄从最初的55周岁下
#降到38周岁，然后一直上升到第40届国王的73周岁。
##########################################################



##########################################################
#分解季节性数据
##########################################################
##########################################################
#一个季节性时间序列包含:
#一个趋势部分，一个季节性部分和一个不规则部分。
#分解时间序列就意味着要把时间序列分解称为这三个部分：
#也就是估计出这三个部分。
##########################################################
##########################################################
#对于可以使用相加模型进行描述的时间序列中的趋势部分和
#季节性部分，我们可以使用R中“decompose()”函数来估计。
#这个函数可以估计出时间序列中趋势的、季节性的和不规则
#的部分，而此时间序列须是可以用相加模型描述的。
##########################################################
##########################################################
#对于可以使用相加模型进行描述的时间序列中的趋势部分和
#季节性部分，我们可以使用R中“decompose()”函数来估计。
#这个函数可以估计出时间序列中趋势的、季节性的和不规则
#的部分，而此时间序列须是可以用相加模型描述的。
##########################################################
##########################################################
#“decompose()”这个函数返回的结果是一个列表对象，
#里面包含了估计出的季节性部分，趋势部分和不规则部分，
#他们分别对应的列表对象元素名为“seasonal”、“trend”、和“random”。
##########################################################

##########################################################
#为了估计时间序列的趋势的、季节性和不规则部分，输入代码：
##########################################################
birthstimeseriescomponents <- decompose(birthstimeseries)
birthstimeseriescomponents
##########################################################
#估计出的季节性、趋势的和不规则部分现在被存储在变量
#birthstimeseriescomponents$seasonal, 
#birthstimeseriescomponents$trend 和
#birthstimeseriescomponents$random 中
##########################################################

##########################################################
#可以使用“plot()”函数画出时间序列中估计的趋势的、
#季节性的和不规则的部分
##########################################################
plot(birthstimeseriescomponents)

##########################################################
#季节性因素调整
##########################################################
##########################################################
#如果这个季节性时间序列可以用相加模型来描述，
#你可以通过估计季节性部分修正时间序列，
#也可以从原始序列中去除掉估计得季节性部分。
#我们可以通过“decompose()”函数使用估计出的季节性部分进行计算。
##########################################################
##########################################################
#例如，对纽约每月出生人口数量进行季节性修正，
#我们可以用“decompose()”估计季节性部分，
#也可以把这个部分从原始时间序列中去除。
##########################################################
birthstimeseriescomponents <- decompose(birthstimeseries)
birthstimeseriesseasonallyadjusted <- birthstimeseries - birthstimeseriescomponents$seasonal
##########################################################
#可以使用“plot()”画出季节性修正时间序列，代码如下
##########################################################
plot(birthstimeseriesseasonallyadjusted)
##########################################################
#这个季节性修正后的时间序列现在仅包含趋势部分和不规则变动部分。
##########################################################










##########################################################
#使用指数平滑法进行预测
##########################################################


##########################################################
#指数平滑法可以用于时间序列数据的短期预测。
##########################################################


##########################################################
#简单指数平滑法
##########################################################


##########################################################
#如果你有一个可用相加模型描述的，
#并且处于恒定水平和没有季节性变动的时间序列
#指数平滑法可以用于时间序列数据的短期预测。
##########################################################



##########################################################
#简单指数平滑法提供了一种方法估计当前时间点上的水平。
#为了准确的估计当前时间的水平，我们使用alpha参数来控制平滑。
#Alpha的取值在0到1之间。当alpha越接近0的时候，
#临近预测的观测值在预测中的权重就越小。
##########################################################

##########################################################
#eg
# http://robjhyndman.com/tsdldata/hurst/precip1.dat
#这个文件包含了伦敦从1813年到1912年全部的每年每英尺降雨量
#（初始数据来自Hipel and McLeod, 1994）
##########################################################
rain <- scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat", skip = 1)
rainseries <- ts(rain, start = c(1813))
plot.ts(rainseries)
##########################################################
#从这个图可以看出整个曲线处于大致不变的水平
#（意思便是大约保持的25英尺左右）。
#其随机变动在整个时间序列的范围内也可以认为是大致不变的，
#所以这个序列也可以大致被描述成为一个相加模型。
#因此，我们可以使用简单指数平滑法对其进行预测。
##########################################################
##########################################################
#为了能够在R中使用简单指数平滑法进行预测，
#我们可以使用R中的“HoltWinters()”函数对预测模型进行修正。
#为了能够在指数平滑法中使用HotlWinters()，
#我们需要在HoltWinters()函数中设定参数beta=FALSE和gamma=FALSE
##########################################################
##########################################################
#HoltWinters()函数返回的是一个变量列表，包含了一些元素名。
##########################################################
rainseriesforecasts <- HoltWinters(rainseries, beta = FALSE, gamma = FALSE)
rainseriesforecasts
##########################################################
#Holt-Winters exponential smoothing without trend and without seasonal component.
#
#Call:
#  HoltWinters(x = rainseries, beta = FALSE, gamma = FALSE)
#Smoothing parameters:
#  alpha: 0.02412151
#beta : FALSE
#gamma: FALSE
#Coefficients:
 # [,1]
#a 24.67819
##########################################################
##########################################################
#HoltWinters()的输出告诉我们alpha参数的估计值约为0.024。这个数字
#非常接近0，告诉我们预测是基于最近的和较远的一些观测值
#（尽管更多的权重在现在的观测值上）。
##########################################################
##########################################################
#我们将HoltWinters()函数的输出结果存储在
#“rainseriesforecasts”这个列表变量里。
#这个HoltWinters()产生的预测呗存储在一个元素名为“fitted”的列表变量里，
#我们可以通过以下代码获得这些值：
##########################################################
rainseriesforecasts$fitted
##########################################################
#可以再画出原始时间序列和预测的，代码如下：
##########################################################
plot(rainseriesforecasts)
##########################################################
#这个图用黑色画出了原始时间序列图，用红色画出了预测的线条。
#在这里，预测的时间序列比原始时间序列数据平滑非常多。
##########################################################
##########################################################
#作为预测准确度的一个度量，
#我们可以计算样本内预测误差的误差平方之和，
#即原始时间序列覆盖的时期内的预测误差。
#这个误差平方法将存储在一个元素名为
#“rainseriesforecasts”（我们称之为“SSE”）的列表变量里
##########################################################
rainseriesforecasts$SSE
##########################################################
#rainseriesforecasts$SSE
#[1] 1828.855
##########################################################

##########################################################
#用时间序列的第一个值作为这个水平的初始值在简单指数平滑法
#中常见的操作。例如，在伦敦降雨量这个时间序列里，第一个值
#为1813年的23.56（英尺）。你可以在HoltWinters()函数中使
#用“l.start”参数指定其味初始值。例如，我们将预测的初始值
#水平设定为23.56，代码如下：
##########################################################
HoltWinters(rainseries, beta = FALSE, gamma = FALSE, l.start = 23.56)
##########################################################
#可以使用R中的“forecast”包中的“forecast.HoltWinters()”
#函数进行更远时间点上的预测。使用Forecast.HoltWinters()函数，
#我们首先得安装R的“forecast”包
##########################################################
install.packages("forecast")
library(forecast)
##########################################################
#当我们使用forecast.HoltWinters()函数时，
#如它的第一个参数(input)，
#你可以在已使用HoltWinters()函数调整后的预测模型中忽略它。
#例如，在下雨的时间序列中，
#使用HoltWinters()做成的预测模型存储在“rainseriesforecasts”变量中。
#你可以使用forecast.HoltWinters()中的参数”h”来制定你想要做多少时间点的预测
##########################################################
##########################################################
#eg:
#要使用forecast.HoltWinters()做1814-1820年（之后8年）的下雨量预测，我们输入：
##########################################################
rainseriesforecasts2 <- forecast.HoltWinters(rainseriesforecasts, h = 8)
rainseriesforecasts2
##########################################################
#
#Point Forecast    Lo 80    Hi 80    Lo 95    Hi 95
#1913       24.67819 19.17493 30.18145 16.26169 33.09470
#1914       24.67819 19.17333 30.18305 16.25924 33.09715
#1915       24.67819 19.17173 30.18465 16.25679 33.09960
##1916       24.67819 19.17013 30.18625 16.25434 33.10204
#1917       24.67819 19.16853 30.18785 16.25190 33.10449
#1918       24.67819 19.16694 30.18945 16.24945 33.10694
#1919       24.67819 19.16534 30.19105 16.24701 33.10938
#1920       24.67819 19.16374 30.19265 16.24456 33.11182
##########################################################
##########################################################
#orecast.HoltWinters()函数给出了一年的预测，
#一个80%的预测区间和一个95%的预测区间的两个预测。
##########################################################
plot.forecast(rainseriesforecasts2)
##########################################################
#这的蓝色线条是预测的1913-1920的降雨量，
#深灰色阴影区域为80%的预测区间，
#淡灰色阴影区域为95%的预测区间。
##########################################################

##########################################################
#使用forecast.HoltWinters()返回的样本内预测误差将被存储
#在一个元素名为“residuals”的列表变量中。
#如果预测模型不可再被优化，连续预测中的预测误差是不相关的。
#换句话说，如果连续预测中的误差是相关的，
#很有可能是简单指数平滑预测可以被另一种预测技术优化。
##########################################################
##########################################################
#为了验证是否如此，我们获取样本误差中1-20阶的相关图。
#我们可以通过R里的“acf()”函数计算预测误差的相关图。
#为了指定我们想要看到的最大阶数，可以使用acf()中的“lag.max”参数。
##########################################################
acf(rainseriesforecasts2$residuals, lag.max = 20)
##########################################################
#可以从样本相关图中看出自相关系数在3阶的时候触及了置信界限。
#为了验证在滞后1-20阶（lags 1-20）时候的非0相关是否显著，
#我们可以使用Ljung-Box检验。这可以通过R中的“Box.test()”函数实现。
#最大阶数我们可以通过Box.test()函数中的“lag”参数来指定。
##########################################################
Box.test(rainseriesforecasts2$residuals, lag = 20, type = 'Ljung-Box')
##########################################################
#
#Box-Ljung test

#data:  rainseriesforecasts2$residuals
#X-squared = 17.4008, df = 20, p-value = 0.6268
##########################################################
##########################################################
#这里Ljung-Box检验统计量为17.4，并且P值是0.6，所以这是不足
#以证明样本内预测误差在1-20阶是非零自相关的。 
#为了确定预测模型不可继续优化，
##我们需要一个好的方法来检验预测误差是正态分布，
#并且均值为零，方差不变。为了检验预测误差是方差不变的，
#我们可以画一个样本内预测误差图：
##########################################################
plot.ts(rainseriesforecasts2$residuals)

##########################################################
##为了检验预测误差是均值为零的正太分布，
#我们可以画出预测误差的直方图，
#并覆盖上均值为零、标准方差的正态分布的曲线图到预测误差上
##########################################################

plotForecastErrors <- function(forecasterrors){
  # make a red histogram of the forecast errors:
  mybinsize <- IQR(forecasterrors)/4 
  mysd <- sd(forecasterrors) 
  mymin <- min(forecasterrors) + mysd*5 
  mymax <- max(forecasterrors) + mysd*3 
  mybins <- seq(mymin, mymax, mybinsize) 
  hist(forecasterrors, col="red", freq=FALSE, breaks=mybins) # freq=FALSE ensures the area under the histogram = 1
  # generate normally distributed data with mean 0 and standard deviation mysd
  mynorm <- rnorm(10000, mean=0, sd=mysd)
  myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
  # plot the normal curve as a blue line on top of the histogram of forecast errors:
  points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)

}

plotForecastErrors(rainseriesforecasts2$residuals)

##########################################################
#图展现出预测误差大致集中分布在零附近，
#或多或少的接近正太分布，
#尽管图形看起来是一个偏向右侧的正态分布。
#然后，右偏是相对较小的
#，我们可以可以认为预测误差是服从均值为零的正态分布。
##########################################################








##########################################################
#霍尔特指数平滑法
##########################################################

##########################################################
#霍尔特指数平滑法
#时间序列可以被描述为一个增长或降低趋势的、没有季节性的相加模型
#可以使用霍尔特指数平滑法对其进行短期预测。
##########################################################
##########################################################
#Holt指数平滑法估计当前时间点的水平和斜率。其平滑化是
#由两个参数控制的，alpha，用于估计当前时间点的水平，
#beta，用于估计当前时间点趋势部分的斜率。
#正如简单指数平滑法一样，alpha和beta参数都介于0到1之间，
#并且当参数越接近0，大多数近期的观测则将占据预测更小的权重。
##########################################################
##########################################################
#数据来源：
#可能可以用相加模型描述的有趋势的、无季节性的时间序列案例就是这
#1866年到1911年每年女人们裙子的直径。这个数据可以从该文件获得
# http://robjhyndman.com/tsdldata/roberts/skirts.dat
#初始数据来自Hipel and McLeod, 1994
##########################################################
skirts <- scan("http://robjhyndman.com/tsdldata/roberts/skirts.dat", skip = 5)
skirtsseries <- ts(skirts, start = c(1866))
plot.ts(skirtsseries)
##########################################################
#可以从此图看出裙子直径长度从1866年的600增加到1880的1050，
#并且在此之后有下降到1911年的520。

#为了进行预测，我们使用R中的HoltWinters()函数对预测模型进行调整。
#为了使用HoltWinters()进行Holt指数平滑法，
#我们需要设定其参数gamma=FALSE（gamma参数常常用于Holt-Winters指数平滑法)
##########################################################
skirtsseriesforexasts <- HoltWinters(skirtsseries, gamma = FALSE)

##########################################################
#Holt-Winters exponential smoothing with trend and without seasonal component.

#Call:
 # HoltWinters(x = skirtsseries, gamma = FALSE)

#Smoothing parameters:
#  alpha: 0.8383481
#beta : 1
#gamma: FALSE

#Coefficients:
 # [,1]
#a 529.308585
#b   5.690464
##########################################################
skirtsseriesforexasts$SSE
##########################################################
# skirtsseriesforexasts$SSE
#[1] 16954.18
##########################################################
##########################################################
#这里的alpha预测值为0.84，beta预测值为1.00。
#这都是非常高的值，告诉我们无论是水平上，还是趋势的斜率，
#当前值大部分都基于时间序列上最近的观测值。这样的直观感觉很好，
#因为其时间序列上的水平和斜率在整个时间段发生了巨大的变化。
#预测样本内误差的误差平方和是16954。
##########################################################
plot(skirtsseriesforexasts)
##########################################################
#从该图我们可以看到样本内预测非常接近观测值，
#尽管他们对观测值来说有一点点延迟。
#可以通过HoltWinters()函数中的“l.start”和“b.start”参数
#去指定水平和趋势的斜率的初始值。常见的设定水平初始值是
#让其等于时间序列的第一个值（在裙子数据中是608），而斜率的初始值则是其第
#二值减去第一个值（在裙子数据中是9）。例如，为了使用Holt指数平
#滑法找到一个在裙边直径数据中合适的预测模型，我们设定其水平初始值为608，趋势部分的斜率初始值为9
##########################################################
HoltWinters(skirtsseries, gamma = FALSE, l.start = 608, b.start = 9)
##########################################################
#Holt-Winters exponential smoothing with trend and without seasonal component.

#Call:
#  HoltWinters(x = skirtsseries, gamma = FALSE, l.start = 608, b.start = 9)

#Smoothing parameters:
 # alpha: 0.8346775
#beta : 1
#gamma: FALSE

#Coefficients:
#  [,1]
#a 529.278637
#b   5.670129
##########################################################


##########################################################
#可以使用“forecast”包中的forecast.HoltWinters()函数预测未来时间而无需覆盖原始序列
#现在有的1866年到1911年的裙边直径时间序列数据，
#因此我们可以预测1912年到1930年（19个点或者更多），并且画出他们
##########################################################
skirtsseriesfoecasts2 <- forecast.HoltWinters(skirtsseriesforexasts, h = 19)
plot.forecast(skirtsseriesfoecasts2)
##########################################################
#预测的部分使用蓝色的线条标识出来了，
#浅蓝色阴影区域为80%预测区间，灰色阴影区间为95%的预测区间。
##########################################################

##########################################################
#简单指数平滑法一样，我们瞧瞧样本内预测误差是否在延迟1-20阶时是非零自相关的，
#以此来检验模型是否还可以被优化
#可以创建一个相关图，进行Ljung-Box检验，代码如下：
##########################################################
acf(skirtsseriesfoecasts2$residuals, lag.max = 20)
Box.test(skirtsseriesfoecasts2$residuals, lag = 20, type = 'Ljung-Box')
##########################################################
#Box-Ljung test
#data:  skirtsseriesfoecasts2$residuals
#X-squared = 19.7312, df = 20, p-value = 0.4749
##########################################################
##########################################################
#这个相关图呈现出样本内预测误差的样本自相关系数在#
#滞后5阶的时候超过了置信边界。不管怎样，我们可以界
#定在前20滞后期中有1/20的自相关值超出95%的显著边界
#是偶然的，当我们进行Ljung-Box检验时，P值为0.47，
#意味着我们是不足以证明样本内预测误差在滞后1-20阶的
#时候是非零自相关的。
##########################################################

##########################################################
#和简单指数平滑法一样，我们应该检查整个序列中的预测误差是
#否是方差不变、服从零均值正态分布的。我们可以画出一个时间
#段预测误差图，和一个附上正太曲线的预测误差分布的直方图：
##########################################################
plot.ts(skirtsseriesfoecasts2$residuals)
plotForecastErrors(skirtsseriesfoecasts2$residuals)
##########################################################
#预测误差的时间曲线图告诉我们预测误差在整个时间段内是大致方差不变的
#这个预测误差的直方图告诉我们预测误差似乎是零均值、方差不变的正态分布。
#Ljung-Box检验告诉我们这是不足以证明预测误差是自相关的，
#而其预测误差的时间曲线图和直方图表示出似乎预测误差是服从零均值、方差不变的正态分布的。
#因此，我们可以总结这Holt指数平滑法为裙边直径提供了一个合适的预测，并且是不可再优化的
#另外，这也意味着基于80%预测区间和95%预测区间的假设是非常合理的。
##########################################################




##########################################################
#Holt-Winters指数平滑法
##########################################################

##########################################################
#有一个增长或降低趋势
#并存在季节性
#可被描述成为相加模型的时间序列，
#可以使用霍尔特-温特指数平滑法对其进行短期预测。
##########################################################

##########################################################
#Holt-Winters指数平滑法估计当前时间点的水平，斜率和季节性部分。
#平滑化依靠三个参数来控制：alpha，beta和gamma，
#分别对应当前时间点上的水平，趋势部分的斜率和季节性部分。
#参数alpha，beta和gamma的取值都在0和1之间，
#并且当其取值越接近0意味着对未来的预测值而言最近的观测值占据相对较小的权重。
##########################################################

##########################################################
#用相加模型描述的并附有趋势性和季节性的时间序列案例，
#便是澳大利亚昆士兰州的海滨纪念品商店的月度销售日志
#可以使用HoltWinters()函数对预测模型进行修正
##########################################################
logsouvenirtimeseries <- log(souvenirtimeseries)
souvenirtimeseriesforecasts <- HoltWinters(logsouvenirtimeseries)
souvenirtimeseriesforecasts
##########################################################
#Holt-Winters exponential smoothing with trend and additive seasonal component.

#Call:
 # HoltWinters(x = logsouvenirtimeseries)

#Smoothing parameters:
#  alpha: 0.413418
#beta : 0
#gamma: 0.9561275

#Coefficients:
 # [,1]
#a   10.37661961
#b    0.02996319
#s1  -0.80952063
#s2  -0.60576477
#s3   0.01103238
#s4  -0.24160551
#s5  -0.35933517
#s6  -0.18076683
#s7   0.07788605
#s8   0.10147055
#s9   0.09649353
#s10  0.05197826
#s11  0.41793637
#s12  1.18088423
##########################################################

##########################################################
#这里alpha，beta和gamma的估计值分别是0.41,0.00和0.96。
#alpha（0.41）是相对较低的，意味着在当前时间点估计得
#水平是基于最近观测和历史观测值。beta的估计值是0.00，
#表明估计出来的趋势部分的斜率在整个时间序列上是不变的，
#并且应该是等于其初始值。这是很直观的感觉，水平改变非常多，
#但是趋势部分的斜率b却仍然是大致相同的。与此相反的，
#gamma的值（0.96）则很高，表明当前时间点的季节性部分的估计仅仅基于最近的观测值。
##########################################################

plot(souvenirtimeseriesforecasts)
##########################################################
#可以从图中看出Holt-Winters指数平滑法是非常成功得预测了季节峰值，
#其峰值大约发生在每年的11月份。
##########################################################

##########################################################
#为了预测非原始时间序列的未来一段时间，
#我们使用“forecast”包中的“forecast.HoltWinters()”函数
#例如，纪念品销售的原始数据是1987年1月到1993年12月。
#如果我们想预测1994年1月到1998年12月（48月或者更多），并且画出预测，代码如下：
##########################################################
souvenirtimeseriesforecasts2 <- forecast.HoltWinters(souvenirtimeseriesforecasts, h = 48)
plot.forecast(souvenirtimeseriesforecasts2)
##########################################################
#蓝色线条显示出来的是预测，灰蓝和灰色阴影分别是80%和95%的预测区间。
##########################################################

##########################################################
#可以通过画相关图和进行Ljung-Box检验来检查样本内预测误差
#在延迟1-20阶时否是非零自相关的，并以此确定预测模型是否可以再被优化。
##########################################################
acf(souvenirtimeseriesforecasts2$residuals, lag.max = 20)
Box.test(souvenirtimeseriesforecasts2$residuals, lag = 20, type = 'Ljung-Box')
##########################################################
#  Box-Ljung test

#data:  souvenirtimeseriesforecasts2$residuals
#X-squared = 17.5304, df = 20, p-value = 0.6183
##########################################################


##########################################################
# 这个样本内预测误差的相关图并没有在延迟1-20阶内自相关系数超过置信界限的。
#而且，Ljung-Box检验的P值是0.6，意味着是不足以证明延迟1-20阶是非零自相关的。
#可以在整个时间段内检验预测误差是否是方差不变，并且服从零均值正态分布的。
#方法是画出预测误差的时间曲线图和直方图（并覆盖上正太曲线）：
##########################################################
plot.ts(souvenirtimeseriesforecasts2$residuals)
plotForecastErrors(souvenirtimeseriesforecasts2$residuals)
##########################################################
#似乎告诉我们预测误差在整个时间段是方差不变的。
#从预测误差的直方图，似乎其预测误差是服从均值为零的正态分布的。
#这是不足以证明预测误差 在延迟 1-20 阶是自相关的，
#并且预测误差 自相关的，整个时间段呈现出服从零均值、方差 零均值、方差
#不变的正态分布。这 不变的正态分布。这 不变的正态分布。这 不变的正态分布。
#这暗示着 暗示着 Holt Holt-WintersWintersWinters WintersWintersWinters指数平滑法为 
#纪念品商店的销售数据提供了一个合适预测模纪念品商店的销售数据提供了一个合适预测模型
#区间的假设 也是 合理 的。
##########################################################





##########################################################
#时间序列的差分
##########################################################


##########################################################
#ARIMAARIMAARIMAARIMAARIMA模型为平稳时间序列定义的。
#因此，如果你从一个非开始首先就需要做差分直 模型为平稳时间序列定义的。
#若必须对时间序列做d阶养分才能得到一个平稳序列，可使用ARIMA(p,d,q)模型，共中，d是差分的阶数
#可使用diff（）函数作时间序列的差分
##########################################################

##########################################################
#我们可以通过键入下面的代码来得到时间序列（数据存于“skirtsseries“）
#的一阶养分，并画出差分序列的图
##########################################################
skirtsseriesdiff1 <- diff(skirtsseries, differences = 1)
plot.ts(skirtsseriesdiff1)
##########################################################
#一阶差分时间序列结果（上图） 一阶差分时间序结果均值看起来并不平稳
#因此，我们需要再次做差分来看一下是否能得到个平稳时间序列
##########################################################
skirtsseriesdiff2 <- diff(skirtsseries, differences = 2)
plot.ts(skirtsseriesdiff2)

##########################################################
#上例中，二次养分后的时间序列在均值和方差上确实看起来像是平稳的，
#随时间推移，时间序列的水平和方差大致保持不变
#因此，看起来需对裙子进行两次差分以得到平稳序列
##########################################################

##########################################################
#对于平稳性正式的检验 
#称作”单位根测试“
#可在fUnitRoots包中得到
##########################################################





##########################################################
#选择一个合适的ARIMA模型
##########################################################

##########################################################
#若时间序列是平稳的，或通过n次差分转化为一个平稳时间序列，
#接下来即选择合适的ARIMA模型，即寻找ARIMA（p,d,q）中合适的p值和q值
#通常需要检查平稳时间序列的（自）相关图和偏相关图
#acf（）和pacf（）
##########################################################


##########################################################
#快捷方式：auto.arima（）函数
#auto.arima（）函数可用以发现合适的ARIMA模型
# library(forecast)
#auto.arima(kings)
##########################################################


##########################################################
#北半球的火山灰覆盖实例
##########################################################
volcanodust <- scan("http://robjhyndman.com/tsdldata/annual/dvi.dat", skip = 1)
volcanodustseries <- ts(volcanodust, start = c(1500))
plot.ts(volcanodustseries)
##########################################################
#从图上看出，随着时间增加，时间序列上面的随机波动逐渐趋与一个常数，
#所以添加一个合适的模型可以很好地描述这个时间序列。
#进一步地，此时间序列看起来在平均值和方差上面是平稳的，
#即随着时间变化，他们的水平和方差大致趋于常量。
#因此，我们不需要做差分来适应ARIMA模型，而是用原始数据就可以找到合适的ARIMA模型
##########################################################

##########################################################
#可以画出滞后1-20阶（lags 1-20）的自相关图和偏相关图来
#观察我们需要使用哪个ARIMA模型。
##########################################################
acf(volcanodustseries, lag.max = 20)
acf(volcanodustseries, lag.max =20, plot = FALSE) # get the values of the autocorrelations


pacf(volcanodustseries, lag.max = 20)
pacf(volcanodustseries, lag.max = 20, plot = FALSE)


##########################################################
#shortcut: the auto.arima() function 快捷方式：auto.arima()函
##########################################################




##########################################################
#英国国王去世年龄的例子
##########################################################
kingstimeseriesarima <- arima(kingstimeseries, order = c(0, 1, 1)) # fit an ARIMA(0,1,1)model
kingstimeseriesarima
##########################################################
#Series: kingstimeseries 
#ARIMA(0,1,1)                    

#Coefficients:
#  ma1
#-0.7218
#s.e.   0.1208

#sigma^2 estimated as 230.4:  log likelihood=-170.06
#AIC=344.13   AICc=344.44   BIC=347.56
##########################################################

##########################################################
#如果我们对时间序列使用ARIMA(0,1,1)模型，那就意味着我们对
#一阶时间序列使用了ARMA(0,1) 模型。 ARMA(0,1) 模型可以写
#作X_t - mu = Z_t - (theta * Z_t-1)，其中theta是被估计的参数。 
#从R 中“arima()”函数的输入（上面），在国王去世年龄的时间序列
#中使用ARIMA(0,1,1) 模型的情况下，theta 的估计值
#(在R输出中以‘ma1’给出) 为-0.7218。
##########################################################
##########################################################
#指定预测区间的置信水平
#使用forecast.Arima() 中“level”参数来确定预测区间的置信水平
#可以使用ARIMA模型来预测时间序列未来的值，使用R中forecast包的“forecast.Arima()” 函数。
##########################################################
library("forecast")
kingstimeseriesforecasts <- forecast.Arima(kingstimeseriesarima, h = 5)
kingstimeseriesforecasts #给出预测
plot.forecast(kingstimeseriesforecasts)


##########################################################
#也要观察连续预测误差是否（自）相关
##########################################################
acf(kingstimeseriesforecasts$residuals, lag.max = 20)
Box.test(kingstimeseriesforecasts$residuals, lag = 20, type = 'Ljung-Box')
##########################################################
#  Box-Ljung test

#data:  kingstimeseriesforecasts$residuals
#X-squared = 13.5844, df = 20, p-value = 0.8509
##########################################################
##########################################################
#既然相关图显示出在滞后1-20阶（lags 1-20）中样本自相关值都
#没有超出显著（置信）边界，而且Ljung-Box检验的p值为0.9，所
#以我们推断在滞后1-20阶（lags 1-20）中没有明显证据说明预测
#误差是非零自相关的。 为了调查预测误差是否是平均值为零且方
#差为常数的正态分布（服从零均值、方差不变的正态分布），我们
#可以做预测误差的时间曲线图和直方图（具有正态分布曲线）：
##########################################################

plot.ts(kingstimeseriesforecasts$residuals)
plotForecastErrors(kingstimeseriesforecasts$residuals)

##########################################################
#既然依次连续的预测误差看起来不是相关，而且看起来是平均值
#为0方差为常数的正态分布（服从零均值、方差不变的正态分布），
#那么对于英国国王去世年龄的数据，ARIMA(0,1,1)看起来是可以
#提供非常合适预测的模型。
##########################################################

